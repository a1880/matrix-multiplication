using System;
using System.Collections.Generic;
using System.Linq;

using static akExtractMatMultSolution.Util;

namespace akExtractMatMultSolution
{
    /// <summary>
    /// Class Subexpression represents are partial sum.
    /// It consists of positive and negative operands.
    /// 
    /// To avoid that multple Subexpression objects with identical content
    /// are stored side-by-side in collections like HashSet, methods Equals()
    /// and GetHashCode() are overridden.
    /// </summary>
    public class Subexpression: IEquatable<Subexpression>
    {
        static int idx = 0;

        /// <summary>
        /// To find the Subexpression generated by RegisterSum(Term)
        /// </summary>
        static readonly Dictionary<string, Subexpression> dicTerm2Subexpression = [];

        /// <summary>
        /// To identify a given object
        /// </summary>
        public readonly int id = ++idx;

        /// <summary>
        /// The number of times the Subexpression occurs in other expressions
        /// </summary>
        private int occurrences = 0;

        /// <summary>
        /// Hashcode is calculated at initialization.
        /// Subexpression objects can be changed, for instance by replacing subexpressions.
        /// This will not change the key and the hashCode. 
        /// They are tied to the original sum string at construction time.
        /// </summary>
        private int hashCode;
        private string key;
        private string[] posOperands;
        private string[] negOperands;

        /// <summary>
        /// Positive operands of the subexpression
        /// </summary>
        public string[] PosOperands => posOperands;

        /// <summary>
        /// Negative operands of the subexpression
        /// </summary>
        public string[] NegOperands => negOperands;

        public int Length => posOperands.Length + negOperands.Length;

        //  Merit is number of operations saved by CSE simplification
        public int Merit => (occurrences < 1) ? 0 : ((Length - 1) * (occurrences - 1));
        public int Occurrences => occurrences;

        private Subexpression()
        {
            Fatal("Subexpression: parameterless constructor called");
        }

        /// <summary>
        /// Copy constructor
        /// </summary>
        /// <param name="other"></param>
        private Subexpression(Subexpression other)
        {
            Fatal("Subexpression: copy constructor called");
            occurrences = other.occurrences;
            SetOperands(other.posOperands, other.negOperands);
        }

        /// <summary>
        /// Construct Subexpression by parsing a sum string
        /// 
        /// The sum string is expected to be a concatenation of identifier names
        /// separated by + or - as operators. Other operators like * are not allowed.
        /// </summary>
        public Subexpression(string sum)
        {
            List<string> posOps = [];
            List<string> negOps = [];
            bool isPos = true;   //  true, iff current operand is positive
            string opName = "";

            //  Register object for later retrieval
            dicTerm2Subexpression[sum] = this;

            // scan sum expression and extract positive and negative operands
            for (int pos = 0; pos < sum.Length; pos++)
            {
                char c = sum[pos];
                if ((c == '+') || (c == '-'))
                {
                    if (opName != "")
                    {
                        (isPos ? posOps : negOps).Add(opName);
                        Check(IsValidIdentifier(opName), "Invalid identifier '{opName}' in '{sum}'");
                    }
                    isPos = (c == '+');
                    opName = "";
                }
                else if ("*;,.:#()[]{}\\\"'".IndexOf(c) >= 0)
                {
                    Fatal($"Character '{c}' not allowed in sum '{sum}'");
                }
                else if (c != ' ')
                {
                    opName += c;
                }
            }

            if (opName != "")
            {
                (isPos ? posOps : negOps).Add(opName);
                Check(IsValidIdentifier(opName), 
                    $"Invalid identifier '{opName}' in '{sum}'");
            }

            posOps.Sort();
            negOps.Sort();

            SetOperands(posOps, negOps);
        }

        /// <summary>
        /// Construct Subexpression from collections of positive and negative operands
        /// </summary>
        private Subexpression(IEnumerable<string> posOps, IEnumerable<string> negOps)
        {
            SetOperands(posOps, negOps);
        }

        /// <summary>
        /// Return all possible Subexpression objects for the this Subexpression
        /// 
        /// Subexpressions already in collection existingSubexpressions are not returned again.
        /// This avoids parallel existence of equal Subexpression objects
        /// </summary>
        public IEnumerable<Subexpression> AllSubexpressions(HashSet<Subexpression> existingSubexpressions)
        {
            for (int noOfOps = 2; noOfOps <= Length; noOfOps++)
            {
                //  Each combination consists of n integers selected from 0..Length-1
                //  This is the turned into a Subexpression with n operands
                var combinations = RosettaCombinations.FindCombinations(noOfOps, Length);

                foreach (IEnumerable<int> ops in combinations)
                    for (int phase = 0; phase < 2; phase++)
                    //  Try wether subexpression exists in direct or inverted form
                    {
                        Subexpression newSubexpression = CreateSubexpression(ops, inverted: phase > 0);
                        Subexpression existingSubexpression = existingSubexpressions.Retrieve(newSubexpression);

                        if ((existingSubexpression == null) && (phase > 0))
                        //  Subexpression does not exist in direct nor in inverted form
                        {
                            yield return newSubexpression;
                        }
                    }
            }
        }

        /// <summary>
        /// Return true, iff 'se' is a direct or inverted subexpression of this
        /// </summary>
        public bool Contains(Subexpression se)
        {
            int count = CountMatchingOperands(se);

            return count != 0;
        }

        /// <summary>
        /// Check how many operands of 'se' are present in 'this'?
        /// 
        /// Return:
        /// +1  all pos operands of se are in this.pos, all se.neg in this.neg
        /// -1  all pos operands of se anr in this.neg. all se.neg in this.pos
        /// 0   no direct or inverted match
        /// </summary>
        private int CountMatchingOperands(Subexpression se)
        {
            int count = 0;
            int invCount = 0;

            if (se.Length <= Length)
            //  No full match is possible, otherwise return 0
            {
                foreach (string sePos in se.posOperands)
                    if (posOperands.Contains(sePos))
                    {
                        count++;
                    }
                    else if (negOperands.Contains(sePos))
                    {
                        invCount++;
                    }
                    else
                    {
                        return 0;
                    }

                foreach (string seNeg in se.negOperands)
                    if (negOperands.Contains(seNeg))
                    {
                        count++;
                    }
                    else if (posOperands.Contains(seNeg))
                    {
                        invCount++;
                    }
                    else
                    {
                        return 0;
                    }
            }

            return (count == se.Length) ? 1 
                 : (invCount == se.Length) ? -1
                 : 0;
        }

        /// <summary>
        /// Count how often this Subexpression is used in the collection exprs
        /// </summary>
        public void CountOccurrences(IEnumerable<Subexpression> exprs)
        {
            occurrences = exprs.Count(se => se.Contains(this));
        }

        private Subexpression CreateSubexpression(IEnumerable<int> ops, bool inverted)
        {
            List<string> pos = [];
            List<string> neg = [];

            foreach(int op in ops)
            {
                if (op < posOperands.Length)
                {
                    pos.Add(posOperands[op]);
                }
                else
                {
                    neg.Add(negOperands[op - posOperands.Length]);
                }
            }

            return inverted ? new Subexpression(pos, neg)
                            : new Subexpression(neg, pos);
        }

        public bool Equals(Subexpression other)
        {
            return (id == other.id) ||
                   (GetHashCode() == other.GetHashCode());
        }

        public override int GetHashCode()
        {
            //  hashCode is calculated during Subexpression object construction to gain speed
            return hashCode;
        }

        private void IsSorted(string[] arr)
        {
            for (int i = 1; i < arr.Length; i++)
            {
                if (arr[i - 1].CompareTo(arr[i]) >= 0)
                {
                    Fatal($"String array is not strictly sorted: {string.Join(" ", arr)}");
                }
            }
        }
        public static bool IsValidIdentifier(string name)
        {
            if ((name == null) || (name == ""))
            {
                return false;
            }

            char c = char.ToLower(name[0]);
            if ((c < 'a') || (c > 'z'))
            {
                return false;
            }

            for (int pos = 1; pos < name.Length; pos++)
            {
                c = char.ToLower(name[pos]);

                if (((c < '0') || (c > '9')) &&
                    ((c < 'a') || (c > 'z')))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Replace subexpression 'expr' by auxiliary variable 'auxName'
        /// </summary>
        public void ReplaceSubexpression(string auxName, Subexpression expr)
        {
            int match = CountMatchingOperands(expr);
            List<string> posOps = [];
            List<string> negOps = [];

            // o($"pre replace: {ToString(verbose:true)}");
            // o($"subexpr:     {expr.ToString(verbose:true)}");
            if (match > 0)
            {
                posOps.AddRange(posOperands.Except(expr.posOperands));
                negOps.AddRange(negOperands.Except(expr.negOperands));
                posOps.Add(auxName);
            }
            else if (match < 0)
            {
                posOps.AddRange(posOperands.Except(expr.negOperands));
                negOps.AddRange(negOperands.Except(expr.posOperands));
                negOps.Add(auxName);
            }
            else
            {
                Fatal("Call Replace() for non-matching Subexpression");
            }

            posOps.Sort();
            negOps.Sort();
            //  Don't change the key.
            //  Otherwise, the changed object cannot be found again.
            SetOperands(posOps, negOps, updateKey:false);
        }

        /// <summary>
        /// Return the Subexpression originally created for sum, null if not found
        /// </summary>
        public static Subexpression Retrieve(string sum)
        {
            if (dicTerm2Subexpression.TryGetValue(sum, out Subexpression se))
            {
                return se;
            }

            Check(false, $"No simplified sum found for '{sum}'");
            //  not reached

            return null;
        }

        private void SetOperands(IEnumerable<string> posOps, IEnumerable<string> negOps, bool updateKey = true)
        {
            posOperands = posOps.ToArray();
            IsSorted(posOperands);
            negOperands = negOps.ToArray();
            IsSorted(negOperands);

            if (updateKey)
            {
                //  Thus, the object is only found under the original ordering.
                key = ToString();
                hashCode = key.GetHashCode();
            }
        }

        public override string ToString()
        {
            return ToString(verbose:false);
        }

        public string ToString(bool verbose)
        {
            List<string> ops = [.. posOperands, .. negOperands];
            ops.Sort();

            string s = "";
            foreach (string op in ops)
            {
                char sign = posOperands.Contains(op) ? '+' : '-';

                s += $" {sign} {op}";
            }

            if (s.StartsWith(" + "))
            {
                s = s.Substring(3);
            }

            if (!verbose || (Merit == 0))
            {
                return s.Trim();
            }

            return $"ID={id} Occ={Occurrences} Merit={Merit} : {s}";
        }
    }
}
