using System;
using static akUtil.Util;

namespace akExtractMatMultSolution
{
    /// <summary>
    /// AST = Abstract Syntax Tree
    /// A tree-structure generated by the parser.
    /// Base class for all AST nodes
    /// Note that two derived classes are defined in YacasChecker.cs:
    /// CoefficientProduct and VariableProduct
    /// </summary>
    public abstract class AstNode
    {
        public virtual void Print(int indent = 0, bool compact = false) { }
        public bool Expanded = false;

        public string OperatorString(TokenType op)
        {
            string s = op switch 
            {
                TokenType.unknown => "???", 
                TokenType.variable => "var",
                TokenType.number => "#",
                TokenType.imaginary => "i",
                TokenType.leftBracket => "(",
                TokenType.rightBracket => ")",
                TokenType.times => "*",
                TokenType.add => "+",
                TokenType.subtract => "-",
                TokenType.end => ";",
                TokenType.show => "show",
                TokenType.error => "error",
                _ => throw new Exception("invalid operator")                
            };

           return s;
        }
    }

    /// <summary>
    /// Node for complex numbers
    /// We handle all literal coefficients as complex.
    /// It does not hurt too much ...
    /// </summary>
    public class ComplexNode(Coefficient value) : AstNode
    {
        readonly Coefficient value = value;

        public Coefficient Value => value;

        public override void Print(int indent = 0, bool compact = false)
        {
            if (!compact)
            {
                o($"~:{new string(' ', indent)}Coefficient: {Value}");
            }
            else
            {
                o($">{Value}");
            }

        }
    }

    /// <summary>
    /// Variables can be either literal (eg a12, or c45)
    /// or products (eg p12)
    /// </summary>
    public class VariableNode : AstNode
    {
        public readonly string Name;

        public VariableNode(string name)
        {
            Name = name;
            if (("abc".IndexOf(name[0]) >= 0) && (name.Length != 3))
            {
                throw new ArgumentException($"'{name}' is not 3 chars long");
            }
        }

        public int Row => ExtractInt(Name, offset:1, length:1);
        public int Col => ExtractInt(Name, offset:2, length:1);
        public int Product => ExtractInt(Name, offset: 1, length: Name.Length - 1);

        public override void Print(int indent = 0, bool compact = false)
        {
            if (!compact)
            {
                o($"~:{new string(' ', indent)}Variable: {Name}");
            }
            else
            {
                o($">{Name}");
            }
        }
    }

    /// <summary>
    /// Node for binary operations (add, subtract, times)
    /// </summary>
    public class BinaryOperationNode(AstNode left, TokenType op, AstNode right) : AstNode
    {
        public AstNode Left { get; } = left;
        public TokenType Operator { get; } = op;
        public AstNode Right { get; } = right;

        public override void Print(int indent = 0, bool compact = false)
        {
            if (!compact)
            {
                o($"~:{new string(' ', indent)}Binary Operation: {Operator}");
                Left.Print(indent + 2);
                Right.Print(indent + 2);
            }
            else
            {
                string op = OperatorString(Operator);

                o(">(");
                Left.Print(compact: compact);
                o($">{op}");
                Right.Print(compact: compact);
                o(">)");
            }
        }
    }

    /// <summary>
    /// Node for unary operations (currently only subtract)
    /// </summary>
    public class UnaryOperationNode(TokenType op, AstNode right) : AstNode
    {
        public TokenType Operator { get; } = op;
        public AstNode Right { get; } = right;

        public override void Print(int indent = 0, bool compact = false)
        {
            if (!compact)
            {
                o($"~:{new string(' ', indent)}Unary Operation: {Operator}");
                Right.Print(indent + 2);
            }
            else
            {
                string op = OperatorString(Operator);
                o($">{op}");
                Right.Print(compact: compact);
            }
        }
    }
}
